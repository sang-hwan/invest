아래 내용은 “1단계: 기초 세팅(개발 환경 & 간단한 백테스트)”을 실제로 수행하기 위한 **예시 가이드**입니다.  
(예시 코드와 패키지 설치 방법은 본인의 환경에 맞춰 조정하세요.)

---

## 1. Python 개발 환경 세팅

### 1.1 가상환경 만들기 (Anaconda 또는 venv 중 택1)

#### (A) Anaconda/Miniconda 사용하는 경우

1. **Miniconda/Anaconda** 설치  
   - [Miniconda 다운로드 링크](https://docs.conda.io/en/latest/miniconda.html)  
2. **새 환경 생성**  
   ```bash
   conda create -n coinbot python=3.9
   ```
3. **환경 활성화**  
   ```bash
   conda activate coinbot
   ```

#### (B) `venv` 사용하는 경우

1. **Python 설치**(3.8 이상 권장)  
2. **가상환경 생성**  
   ```bash
   python -m venv coinbot_env
   ```
3. **가상환경 활성화**  
   - Windows:  
     ```bash
     coinbot_env\Scripts\activate
     ```
   - Mac/Linux:  
     ```bash
     source coinbot_env/bin/activate
     ```

---

## 2. 라이브러리 설치

가상환경이 활성화된 상태에서 아래 명령어를 통해 필요한 라이브러리를 설치하세요.

```bash
pip install pandas numpy matplotlib
```

- **pandas**: 데이터프레임 형태로 시세데이터 다루기 편리  
- **numpy**: 수치 계산  
- **matplotlib**: 간단 차트 시각화

> 만약 **backtrader**나 **freqtrade** 등 프레임워크를 사용하고 싶다면, 추가로 설치하세요.  
> 예: `pip install backtrader`

---

## 3. 거래소 API 확인 및 간단 테스트

이번 1단계에서는 **굳이 실제 API로 주문**을 넣지는 않을 겁니다. 다만, **시세 데이터(OHLCV 등)** 를 불러올 수 있는지 확인하기 위해, 대표적으로 [CCXT](https://github.com/ccxt/ccxt) 라이브러리를 사용해볼 수 있습니다.

### 3.1 CCXT 설치

```bash
pip install ccxt
```

### 3.2 간단한 시세 조회 (예: 바이낸스 BTC/USDT)

아래 예시는 **최근 며칠분의 BTC/USDT 일봉(1일 캔들)** 데이터를 가져와서 출력하는 간단한 코드입니다.

```python
import ccxt
import pandas as pd

# 1) 거래소 객체 생성
binance = ccxt.binance()

# 2) OHLCV 데이터 불러오기 (BTC/USDT, 1일봉, 최근 100개)
ohlcv = binance.fetch_ohlcv('BTC/USDT', timeframe='1d', limit=100)

# 3) DataFrame 변환
df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])

# 4) 타임스탬프를 사람이 읽을 수 있는 날짜로 변환
df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')

print(df.head())
```

> 위 코드 실행 후, 정상적으로 데이터프레임이 출력되면 **API 통신이 성공**한 것입니다.

- 업비트 등 다른 거래소를 쓰고 싶다면 `ccxt.upbit()` 처럼 교체하시고, 심볼(마켓명)도 알맞게 변경하세요.  
- 만약 해당 거래소에서 데이터를 지원하지 않거나 제한적인 경우, 대안으로 API 문서(REST API)를 직접 참고해 HTTP 요청을 작성할 수도 있습니다.

---

## 4. 간단한 백테스트 (SMA Cross 예시)

이번 단계 목표는 **정말 간단한 전략**이라도 “백테스트가 돌아간다”는 것을 확인하는 겁니다.  
**단순 이동평균선(SMA) 2개**를 이용한 크로스 전략 예시 코드를 소개합니다.

### 4.1 예시 전략 설명

- **단순 이동평균 5일선** (단기)  
- **단순 이동평균 20일선** (장기)  
- 매수 시점: 단기 SMA가 장기 SMA를 **상향 돌파**할 때(골든크로스)  
- 매도 시점: 단기 SMA가 장기 SMA를 **하향 돌파**할 때(데드크로스)  
- 각 신호가 발생할 때, 1회분량 **매수/매도**한다고 가정(포지션은 최대 1개만 보유)

### 4.2 코드 예시

```python
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import ccxt

# -- 1) 시세 데이터 불러오기 (예시: 바이낸스 BTC/USDT 일봉) --
binance = ccxt.binance()
ohlcv = binance.fetch_ohlcv('BTC/USDT', timeframe='1d', limit=200)
df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
df.set_index('timestamp', inplace=True)  # 인덱스를 날짜로 지정

# -- 2) 단순 이동평균(SMA) 계산 --
df['SMA_5'] = df['close'].rolling(5).mean()
df['SMA_20'] = df['close'].rolling(20).mean()

# -- 3) 매매 신호 생성 (단순 로직) --
# 골든크로스: SMA_5가 SMA_20을 상향 돌파하면 +1 (매수), 하향 돌파하면 -1 (매도)
df['signal'] = 0
df['signal'] = np.where((df['SMA_5'] > df['SMA_20']) & (df['SMA_5'].shift(1) <= df['SMA_20'].shift(1)), 1, df['signal'])
df['signal'] = np.where((df['SMA_5'] < df['SMA_20']) & (df['SMA_5'].shift(1) >= df['SMA_20'].shift(1)), -1, df['signal'])

# -- 4) 포지션 보유 상태 추적 (단순히 1 = 매수, -1 = 매도, 0 = 홀딩) --
df['position'] = df['signal'].replace(to_replace=0, method='ffill').fillna(0)
# signal이 0이면 이전 포지션 그대로 유지
# fillna(0)는 초기 NaN값을 0으로

# 단순하게 "position=1일 때만 코인을 보유"한다고 가정
df['strategy_return'] = df['position'].shift(1) * (df['close'].pct_change())

# -- 5) 누적수익률 계산 --
df['cum_strategy_return'] = (1 + df['strategy_return']).cumprod()

# -- 6) 시각화 (전략 누적수익 vs 종목 단순 보유) --
df['cum_buy_and_hold'] = (df['close'] / df['close'].iloc[0])  # buy&hold 가정
plt.figure(figsize=(12,6))
plt.plot(df.index, df['cum_strategy_return'], label='SMA Cross Strategy')
plt.plot(df.index, df['cum_buy_and_hold'], label='Buy & Hold')
plt.legend()
plt.show()

# -- 7) 결과 확인 --
final_strategy = df['cum_strategy_return'].iloc[-1]
final_buyhold = df['cum_buy_and_hold'].iloc[-1]
print(f"전략 누적수익 배율: {final_strategy:.2f}")
print(f"Buy & Hold 대비 배율: {final_buyhold:.2f}")
```

#### 4.3 코드 실행 후 확인할 점

- **전략 누적수익 배율**이 1.0 이상이면, 해당 기간 동안 **수익이 났다**는 의미입니다.  
- **Buy & Hold 대비**로 어느 정도인지 간단 비교해볼 수 있습니다.  
- 이 전략은 매우 단순하므로, 실제로는 변동성이나 슬리피지, 수수료 등을 고려해야 합니다.  
- 그래프가 잘 출력된다면, “백테스트 결과를 시각적으로 검토”할 수 있습니다.

---

## 5. 이번 단계(1단계)의 목표 정리

1. **개발 환경**(가상환경 + 라이브러리)이 정상적으로 동작하는지 확인  
2. **시세 데이터(API)** 를 불러와서 **DataFrame** 형태로 가공해볼 수 있는지 확인  
3. **아주 간단한 백테스트**를 수행해보고 결과(수익곡선, 지표 등)를 확인  

이 과정을 통해, 앞으로 진행할 **자동매매** 로직의 **기초 뼈대**를 마련하게 됩니다.

---

### 다음에 할 일

> 이제 1단계가 어느 정도 완료되면, 2단계인 **MVP(최소기능) 개발 & 모의투자**로 넘어가시면 됩니다.  
> - **실시간 시세 가져오기**,  
> - **단순 전략을 일정 주기로 돌려 매매 시뮬레이션** 해보기,  
> - 이후 실제 소액으로 매매해보기(3단계) …  
> 이런 식으로 단계별로 범위 확장하시면 됩니다.

---

## 결론

이상으로, **1단계(기초 세팅)** 에서 해야 할 일을 실제 코드 예시와 함께 살펴봤습니다.  
- **가상환경 세팅** → **필수 라이브러리 설치** → **거래소 API로 간단한 시세 조회 테스트** → **아주 기초적인 백테스트**  
- 우선은 “코드가 에러 없이 잘 돌아가고, 간단한 결과를 확인할 수 있는지”가 중요합니다.

이 과정을 문제 없이 마쳤다면, 이제 **2단계(MVP + 모의투자)** 로 넘어갈 준비가 된 것입니다.  
차근차근 진행해보세요!  